---
title: Credit Risk Modeling in R
author: ''
date: '2021-09-22'
slug: credit-risk-modeling-in-r
categories: []
tags:
  - logistic regression
  - decision trees
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>This hands-on-course with real-life credit data will teach you how to model credit risk by using logistic regression and decision trees in R.</p>
<p>Modeling credit risk for both personal and company loans is of major importance for banks. The probability that a debtor will default is a key component in getting to a measure for credit risk. While other models will be introduced in this course as well, you will learn about two model types that are often used in the credit scoring context; logistic regression and decision trees. You will learn how to use them in this particular context, and how these models are evaluated by banks.</p>
<div id="exploring-the-credit-data" class="section level2">
<h2>1-2 Exploring the credit data</h2>
<p>We will be examining the dataset loan_data discussed in the video throughout the exercises in this course.</p>
<p>After being given loan_data, you are particularly interested about the defaulted loans in the data set. You want to get an idea of the number, and percentage of defaults. Defaults are rare, so you always want to check what the proportion of defaults is in a loan dataset. The CrossTable() function is very useful here.</p>
<p>Remember that default information is stored in the response variable loan_status, where 1 represents a default, and 0 represents non-default.</p>
<p>To learn more about variable structures and spot unexpected tendencies in the data, you should examine the relationship between loan_status and certain factor variables. For example, you would expect that the proportion of defaults in the group of customers with grade G (worst credit rating score) is substantially higher than the proportion of defaults in the grade A group (best credit rating score).</p>
<p>Conveniently, CrossTable() can also be applied on two categorical variables. Let’s explore!</p>
<pre class="r"><code># View the structure of loan_data
str(loan_data)</code></pre>
<pre><code>## &#39;data.frame&#39;:    29092 obs. of  8 variables:
##  $ loan_status   : int  0 0 0 0 0 0 1 0 1 0 ...
##  $ loan_amnt     : int  5000 2400 10000 5000 3000 12000 9000 3000 10000 1000 ...
##  $ int_rate      : num  10.6 NA 13.5 NA NA ...
##  $ grade         : Factor w/ 7 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 2 3 3 1 5 2 3 2 2 4 ...
##  $ emp_length    : int  10 25 13 3 9 11 0 3 3 0 ...
##  $ home_ownership: Factor w/ 4 levels &quot;MORTGAGE&quot;,&quot;OTHER&quot;,..: 4 4 4 4 4 3 4 4 4 4 ...
##  $ annual_inc    : num  24000 12252 49200 36000 48000 ...
##  $ age           : int  33 31 24 39 24 28 22 22 28 22 ...</code></pre>
<pre class="r"><code># Call CrossTable() on loan_status
CrossTable(loan_data$loan_status)</code></pre>
<pre><code>## 
##  
##    Cell Contents
## |-------------------------|
## |                       N |
## |         N / Table Total |
## |-------------------------|
## 
##  
## Total Observations in Table:  29092 
## 
##  
##           |         0 |         1 | 
##           |-----------|-----------|
##           |     25865 |      3227 | 
##           |     0.889 |     0.111 | 
##           |-----------|-----------|
## 
## 
## 
## </code></pre>
<pre class="r"><code># Call CrossTable() on grade and loan_status
CrossTable(loan_data$grade, loan_data$loan_status, prop.r = TRUE, prop.c = FALSE, prop.t = FALSE, prop.chisq = FALSE)</code></pre>
<pre><code>## 
##  
##    Cell Contents
## |-------------------------|
## |                       N |
## |           N / Row Total |
## |-------------------------|
## 
##  
## Total Observations in Table:  29092 
## 
##  
##                 | loan_data$loan_status 
## loan_data$grade |         0 |         1 | Row Total | 
## ----------------|-----------|-----------|-----------|
##               A |      9084 |       565 |      9649 | 
##                 |     0.941 |     0.059 |     0.332 | 
## ----------------|-----------|-----------|-----------|
##               B |      8344 |       985 |      9329 | 
##                 |     0.894 |     0.106 |     0.321 | 
## ----------------|-----------|-----------|-----------|
##               C |      4904 |       844 |      5748 | 
##                 |     0.853 |     0.147 |     0.198 | 
## ----------------|-----------|-----------|-----------|
##               D |      2651 |       580 |      3231 | 
##                 |     0.820 |     0.180 |     0.111 | 
## ----------------|-----------|-----------|-----------|
##               E |       692 |       176 |       868 | 
##                 |     0.797 |     0.203 |     0.030 | 
## ----------------|-----------|-----------|-----------|
##               F |       155 |        56 |       211 | 
##                 |     0.735 |     0.265 |     0.007 | 
## ----------------|-----------|-----------|-----------|
##               G |        35 |        21 |        56 | 
##                 |     0.625 |     0.375 |     0.002 | 
## ----------------|-----------|-----------|-----------|
##    Column Total |     25865 |      3227 |     29092 | 
## ----------------|-----------|-----------|-----------|
## 
## </code></pre>
</div>
<div id="histograms" class="section level2">
<h2>1-5 Histograms</h2>
<p>The data set loan_data is loaded in your workspace. You previously explored categorical variables using the CrossTable() function. Now you would like to explore continuous variables to identify potential outliers or unexpected data structures.</p>
<p>To do this, let’s experiment with the function hist() to understand the distribution of the number of loans for different customers.</p>
<pre class="r"><code>loan_data %&gt;% ggplot(aes(loan_amnt))+ geom_histogram(bins = 30, fill=&quot;white&quot;, color=&quot;black&quot;)+
  labs(x = &quot;Loan amount&quot;, title = &quot;Histogram of the loan amount&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="outliers" class="section level2">
<h2>1-6 Outliers</h2>
<p>Now it’s time to look at the structure of the variable age. A histogram is plotted on your right. Similar to what you observed in the video for annual income (annual_inc), there is a lot of blank space on the right-hand side of the plot. This is an indication of possible outliers. You will look at a scatterplot to verify this. If you find any outliers you will delete them.</p>
<p>If outliers are observed for several variables, it might be useful to look at bivariate plots. It’s possible the outliers belong to the same observation. If so, there is even more reason to delete the observation because it is more likely that some information stored in it is wrong.</p>
<pre class="r"><code># Plot the age variable
loan_data %&gt;% ggplot(aes(as.numeric(rownames(loan_data)), age))+ geom_point()+
  labs(x=&quot;Index&quot;, y = &quot;Age&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># Save the outlier&#39;s index to index_highage
index_highage &lt;- which(loan_data$age &gt; 122)

# Create data set new_data with outlier deleted
new_data &lt;- loan_data[-index_highage, ]

# Make bivariate scatterplot of age and annual income

loan_data %&gt;% ggplot(aes(age, annual_inc))+ geom_point()+
  labs(x=&quot;Age&quot;, y = &quot;Annual Income&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-2.png" width="672" /></p>
</div>
<div id="deleting-missing-data" class="section level2">
<h2>1-8 Deleting missing data</h2>
<p>You saw before that the interest rate (int_rate) in the data set loan_data depends on the customer. Unfortunately some observations are missing interest rates. You now need to identify how many interest rates are missing and then delete them.</p>
<p>In this exercise you will use the function which() to create an index of rows that contain an NA. You will then use this index to delete rows with NAs.</p>
<pre class="r"><code>library(naniar)
vis_miss(loan_data)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code># Look at summary of loan_data
 summary(loan_data$int_rate)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##    5.42    7.90   10.99   11.00   13.47   23.22    2776</code></pre>
<pre class="r"><code># Get indices of missing interest rates: na_index
na_index &lt;- which(is.na(loan_data$int_rate))

# Remove observations with missing interest rates: loan_data_delrow_na
loan_data_delrow_na &lt;- loan_data[-na_index, ]

# Make copy of loan_data
loan_data_delcol_na &lt;- loan_data

# Delete interest rate column from loan_data_delcol_na
loan_data_delcol_na$int_rate &lt;- NULL</code></pre>
</div>
<div id="replacing-missing-data" class="section level2">
<h2>1-9 Replacing missing data</h2>
<p>Rather than deleting the missing interest rates, you may want to replace them instead. The object na_index, which contains the index of the observations with missing interest rates is still loaded in your workspace.</p>
<pre class="r"><code># Compute the median of int_rate
median_ir &lt;- median(loan_data$int_rate, na.rm=TRUE)

# Make copy of loan_data
loan_data_replace &lt;- loan_data

# Replace missing interest rates with median
loan_data_replace$int_rate[which(is.na(loan_data$int_rate))] &lt;- median_ir

# Check if the NAs are gone
summary(loan_data_replace$int_rate)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    5.42    8.49   10.99   11.00   13.11   23.22</code></pre>
</div>
<div id="keeping-missing-data" class="section level2">
<h2>1-10 Keeping missing data</h2>
<p>In some situations, the fact that an input is missing is important information in itself. NAs can be kept in a separate “missing” category using coarse classification.</p>
<p>Coarse classification allows you to simplify your data and improve the interpretability of your model. Coarse classification requires you to bin your responses into groups that contain ranges of values. You can use this binning technique to place all NAs in their own bin.</p>
<p>In the video, we illustrated the idea of coarse classification for employment length. The code from that example has been reproduced in the R script to the right and can be adapted to coarse classify the int_rate variable.</p>
<pre class="r"><code># Make the necessary replacements in the coarse classification example below 
loan_data$ir_cat &lt;- rep(NA, length(loan_data$int_rate))

loan_data$ir_cat[which(loan_data$int_rate &lt;= 8)] &lt;- &quot;0-8&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 8 &amp; loan_data$int_rate &lt;= 11)] &lt;- &quot;8-11&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 11 &amp; loan_data$int_rate &lt;= 13.5)] &lt;- &quot;11-13.5&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 13.5)] &lt;- &quot;13.5+&quot;
loan_data$ir_cat[which(is.na(loan_data$int_rate))] &lt;- &quot;Missing&quot;

loan_data$ir_cat &lt;- as.factor(loan_data$ir_cat)

# Look at your new variable using plot()
loan_data %&gt;% ggplot(aes(ir_cat))+ geom_bar(fill=&quot;grey&quot;, color=&quot;black&quot;, width = 0.8)+theme_minimal()</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="splitting-the-data-set" class="section level2">
<h2>1-12 Splitting the data set</h2>
<p>To make your training and test sets, you should first set a seed using set.seed(). Seeds allow you to create a starting point for randomly generated numbers, so that each time your code is run the same answer is generated. The advantage of doing this in your sampling is that you or anyone else can recreate the exact same training and test sets by using the same seed.</p>
<p>Using sample(), you can randomly assign observations to the training and test set.</p>
<p>For this exercise you will use the two first arguments in the sample() function:</p>
<p>The first argument is the vector from which we will sample values. We will randomly pick row numbers as indices; you can use 1:nrow(loan_data) to create the vector of row numbers.
The second argument is the number of items to choose. We will enter 2 / 3 * nrow(loan_data), as we construct the training set first.</p>
<pre class="r"><code># Set seed of 567
set.seed(567)

# Store row numbers for training set: index_train
index_train &lt;- sample(1:nrow(loan_data), 2 / 3 * nrow(loan_data))

# Create training set: training_set
training_set &lt;- loan_data[index_train, ]

# Create test set: test_set
test_set &lt;- loan_data[-index_train, ]</code></pre>
</div>
<div id="creating-a-confusion-matrix" class="section level2">
<h2>1-13 Creating a confusion matrix</h2>
<p>In this example, assume that you have run a model and stored the predicted outcomes in a vector called model_pred. You want to see how the model performed so you will construct a confusion matrix. You will compare the actual loan status column (loan_status) to the predicted values (model_pred), using the table() function, where the arguments are the true values and the predicted values. Recall the confusion matrix structure:</p>
<div class="figure">
<img src="1.JPG" alt="" />
<p class="caption">Caption for the picture.</p>
</div>
<pre class="r"><code># Create confusion matrix
 conf_matrix &lt;- table(test_set$loan_status, model_pred$x)
conf_matrix</code></pre>
<pre><code>##    
##        0    1
##   0 6025 2584
##   1  755  334</code></pre>
<pre class="r"><code># Compute classification accuracy
(conf_matrix[1,1]+conf_matrix[2,2])/(conf_matrix[1,1]+conf_matrix[2,2]+conf_matrix[2,1]+conf_matrix[1,2])</code></pre>
<pre><code>## [1] 0.6557022</code></pre>
<pre class="r"><code># Compute sensitivity
conf_matrix[2,2]/(conf_matrix[2,1]+conf_matrix[2,2])</code></pre>
<pre><code>## [1] 0.3067034</code></pre>
</div>
<div id="basic-logistic-regression" class="section level2">
<h2>2-2 Basic logistic regression</h2>
<p>In the video, you looked at a logistic regression model including the variable age as a predictor. Now, you will include a categorical variable, and learn how to interpret its parameter estimates.</p>
<p>When you include a categorical variable in a logistic regression model in R, you will obtain a parameter estimate for all but one of its categories. This category for which no parameter estimate is given is called the reference category. The parameter for each of the other categories represents the odds ratio in favor of a loan default between the category of interest and the reference category. Don’t worry if this doesn’t make complete sense to you yet, you’ll do more exercises on this later on!</p>
<pre class="r"><code># Build a glm model with variable ir_cat as a predictor
log_model_cat &lt;- glm(loan_status ~ ir_cat, family = &quot;binomial&quot;, data = training_set)


# Print the parameter estimates 
log_model_cat</code></pre>
<pre><code>## 
## Call:  glm(formula = loan_status ~ ir_cat, family = &quot;binomial&quot;, data = training_set)
## 
## Coefficients:
##   (Intercept)  ir_cat11-13.5    ir_cat13.5+     ir_cat8-11  ir_catMissing  
##       -2.9091         1.0071         1.3874         0.5933         0.7937  
## 
## Degrees of Freedom: 19393 Total (i.e. Null);  19389 Residual
## Null Deviance:       13460 
## Residual Deviance: 13050     AIC: 13060</code></pre>
<pre class="r"><code># Look at the different categories in ir_cat using table()
table(loan_data$ir_cat)</code></pre>
<pre><code>## 
##     0-8 11-13.5   13.5+    8-11 Missing 
##    7130    6954    6002    6230    2776</code></pre>
<pre class="r"><code># to access coefficients:
log_model_cat$coefficients</code></pre>
<pre><code>##   (Intercept) ir_cat11-13.5   ir_cat13.5+    ir_cat8-11 ir_catMissing 
##    -2.9090889     1.0070805     1.3874444     0.5933475     0.7936856</code></pre>
</div>
<div id="multiple-variables-in-a-logistic-regression-model" class="section level2">
<h2>2-4 Multiple variables in a logistic regression model</h2>
<p>The interpretation of a single parameter still holds when including several variables in a model. When you do include several variables and ask for the interpretation when a certain variable changes, it is assumed that the other variables remain constant, or unchanged. There is a fancy latin phrase for this, ceteris paribus, literally meaning “keeping all others the same”.</p>
<p>To build a logistic regression model with multiple variables, you can use the + sign to add variables. Your formula will look something like:</p>
<p>y ~ x1 + … + xk</p>
<p>In order to evaluate the model there are a number of things to be aware of. You already looked at the parameter values, but that is not the only thing of importance. Also important is the statistical significance of a certain parameter estimate. The significance of a parameter is often referred to as a p-value, however in a model output you will see it denoted as Pr(&gt;|t|). In glm, mild significance is denoted by a “.” to very strong significance denoted by "***". When a parameter is not significant, this means you cannot assure that this parameter is significantly different from 0. Statistical significance is important. In general, it only makes sense to interpret the effect on default for significant parameters.</p>
<pre class="r"><code># Build the logistic regression model
log_model_multi &lt;- glm(loan_status ~ age+ir_cat+grade+loan_amnt+annual_inc, family = &quot;binomial&quot;, data = training_set)</code></pre>
<pre><code>## Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred</code></pre>
<pre class="r"><code># Obtain significance levels using summary()
summary(log_model_multi)</code></pre>
<pre><code>## 
## Call:
## glm(formula = loan_status ~ age + ir_cat + grade + loan_amnt + 
##     annual_inc, family = &quot;binomial&quot;, data = training_set)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.1959  -0.5329  -0.4383  -0.3322   3.2329  
## 
## Coefficients:
##                 Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)   -2.428e+00  1.284e-01 -18.920  &lt; 2e-16 ***
## age           -3.980e-03  3.863e-03  -1.030   0.3029    
## ir_cat11-13.5  7.018e-01  1.313e-01   5.344 9.08e-08 ***
## ir_cat13.5+    6.556e-01  1.462e-01   4.485 7.31e-06 ***
## ir_cat8-11     4.867e-01  1.160e-01   4.196 2.71e-05 ***
## ir_catMissing  5.067e-01  1.275e-01   3.973 7.09e-05 ***
## gradeB         1.427e-01  1.041e-01   1.370   0.1707    
## gradeC         4.806e-01  1.200e-01   4.006 6.18e-05 ***
## gradeD         8.033e-01  1.365e-01   5.887 3.93e-09 ***
## gradeE         9.689e-01  1.643e-01   5.896 3.73e-09 ***
## gradeF         1.512e+00  2.296e-01   6.584 4.58e-11 ***
## gradeG         2.072e+00  3.443e-01   6.019 1.76e-09 ***
## loan_amnt     -8.438e-06  4.208e-06  -2.005   0.0449 *  
## annual_inc    -4.788e-06  7.365e-07  -6.502 7.95e-11 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 13460  on 19393  degrees of freedom
## Residual deviance: 12892  on 19380  degrees of freedom
## AIC: 12920
## 
## Number of Fisher Scoring iterations: 5</code></pre>
</div>
<div id="predicting-the-probability-of-default" class="section level2">
<h2>2-7 Predicting the probability of default</h2>
<p>In the video you looked at the predicted probability of default for one case in the test set. Luckily, you can predict the probability for all the test set cases at once using the predict() function.</p>
<p>After having obtained all the predictions for the test set elements, it is useful to get an initial idea of how good the model is at discriminating by looking at the range of predicted probabilities. A small range means that predictions for the test set cases do not lie far apart, and therefore the model might not be very good at discriminating good from bad customers. With low default percentages, you will notice that in general, very low probabilities of default are predicted. It’s time to have a look at a first model.</p>
<p>log_model_small is loaded in the workspace.</p>
<pre class="r"><code>log_model_small &lt;- glm(formula = loan_status ~ age + ir_cat, family = &quot;binomial&quot;, data = training_set)

# Build the logistic regression model
predictions_all_small &lt;- predict(log_model_small, newdata = test_set2, type = &quot;response&quot;)

# Look at the range of the object &quot;predictions_all_small&quot;
range(predictions_all_small)</code></pre>
<pre><code>## [1] 0.03676511 0.18829001</code></pre>
<pre class="r"><code>min(predictions_all_small)</code></pre>
<pre><code>## [1] 0.03676511</code></pre>
<pre class="r"><code>max(predictions_all_small)</code></pre>
<pre><code>## [1] 0.18829</code></pre>
</div>
<div id="making-more-discriminative-models" class="section level2">
<h2>2-8 Making more discriminative models</h2>
<p>In the previous exercise, the range for predicted probabilities of default was rather small. As discussed, small predicted default probabilities are to be expected with low default rates, but building bigger models (which basically means: including more predictors) can expand the range of your predictions.</p>
<p>Whether this will eventually lead to better predictions still needs to be validated and depends on the quality of the newly included predictors. But first, have a look at how bigger models can expand the range.</p>
<pre class="r"><code>training_set &lt;- readRDS(&quot;loan_data_ch2.rds&quot;)

# Build the logistic regression model
log_model_full &lt;- glm(loan_status ~ ., family = &quot;binomial&quot;, data = training_set)

# Make PD-predictions for all test set elements using the the full logistic regression model
predictions_all_full &lt;- predict(log_model_full, newdata = test_set2, type = &quot;response&quot;)

# Look at the predictions range
range(predictions_all_full)</code></pre>
<pre><code>## [1] 4.531443e-06 5.166014e-01</code></pre>
<pre class="r"><code>str(training_set)</code></pre>
<pre><code>## &#39;data.frame&#39;:    29091 obs. of  8 variables:
##  $ loan_status   : int  0 0 0 0 0 0 1 0 1 0 ...
##  $ loan_amnt     : int  5000 2400 10000 5000 3000 12000 9000 3000 10000 1000 ...
##  $ grade         : Factor w/ 7 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 2 3 3 1 5 2 3 2 2 4 ...
##  $ home_ownership: Factor w/ 4 levels &quot;MORTGAGE&quot;,&quot;OTHER&quot;,..: 4 4 4 4 4 3 4 4 4 4 ...
##  $ annual_inc    : num  24000 12252 49200 36000 48000 ...
##  $ age           : int  33 31 24 39 24 28 22 22 28 22 ...
##  $ emp_cat       : Factor w/ 5 levels &quot;0-15&quot;,&quot;15-30&quot;,..: 1 2 1 1 1 1 1 1 1 1 ...
##  $ ir_cat        : Factor w/ 5 levels &quot;0-8&quot;,&quot;11-13.5&quot;,..: 4 5 2 5 5 2 2 4 4 3 ...</code></pre>
</div>
<div id="specifying-a-cut-off" class="section level2">
<h2>2-10 Specifying a cut-off</h2>
<p>We have shown you how the specification of a cut-off can make the difference to obtain a good confusion matrix. Now, you will learn how to transform the prediction vector to a vector of binary values indicating the status of the loan. The ifelse() function in R can help you here.</p>
<p>Applying the ifelse() function in the context of a cut-off, you would have something like</p>
<p>ifelse(predictions &gt; 0.3, 1, 0)</p>
<p>In the first argument, you are testing whether a certain value in the predictions-vector is bigger than 0.3. If this is TRUE, R returns “1” (specified in the second argument), if FALSE, R returns “0” (specified in the third argument), representing “default” and “no default”, respectively.</p>
<pre class="r"><code># The code for the logistic regression model and the predictions is given below
log_model_full &lt;- glm(loan_status ~ ., family = &quot;binomial&quot;, data = training_set)
predictions_all_full &lt;- predict(log_model_full, newdata = test_set2, type = &quot;response&quot;)

# Make a binary predictions-vector using a cut-off of 15%
pred_cutoff_15 &lt;- ifelse(predictions_all_full&gt;0.15, 1, 0)

# Construct a confusion matrix
table(test_set2$loan_status, pred_cutoff_15)</code></pre>
<pre><code>##    pred_cutoff_15
##        0    1
##   0 6810 1850
##   1  642  395</code></pre>
</div>
<div id="comparing-link-functions-for-a-given-cut-off" class="section level2">
<h2>2-13 Comparing link functions for a given cut-off</h2>
<p>In this last exercise, you will fit a model using each of the three link functions (logit, probit and cloglog), make predictions for the test set, classify the predictions in the appropriate group (default versus non-default) for a given cut-off, make a confusion matrix and compute the accuracy and sensitivity for each of the models given the cut-off value! Wow, you’ve learned a lot so far. And finally, you will try to identify the model that performs best in terms of accuracy given the cut-off value!</p>
<p>It is important to know that the differences between the models will generally be very small, and again, the results will depend on the chosen cut-off value. The observed outcome (default versus non-default) is stored in true_val in the console.</p>
<pre class="r"><code># Fit the logit, probit and cloglog-link logistic regression models
log_model_logit &lt;- glm(loan_status ~ age + emp_cat + ir_cat + loan_amnt,
                      family = binomial(link = logit), data = training_set)

log_model_probit &lt;- glm(loan_status ~ age + emp_cat + ir_cat + loan_amnt,
                       family = binomial(link = probit), data = training_set)

log_model_cloglog &lt;-  glm(loan_status ~ age + emp_cat + ir_cat + loan_amnt,
                       family = binomial(link = cloglog), data = training_set)
  
# Make predictions for all models using the test set
predictions_logit &lt;- predict(log_model_logit, newdata = test_set2, type = &quot;response&quot;)
predictions_probit &lt;- predict(log_model_probit, newdata = test_set2, type = &quot;response&quot;)
predictions_cloglog &lt;- predict(log_model_cloglog, newdata = test_set2, type = &quot;response&quot;)
  
# Use a cut-off of 14% to make binary predictions-vectors
cutoff &lt;- 0.14
class_pred_logit &lt;- ifelse(predictions_logit &gt; cutoff, 1, 0)
class_pred_probit &lt;- ifelse(predictions_probit &gt; cutoff, 1, 0)
class_pred_cloglog &lt;- ifelse(predictions_cloglog &gt; cutoff, 1, 0)
  
# Make a confusion matrix for the three models
#tab_class_logit &lt;- table(true_val,class_pred_logit)
#tab_class_probit &lt;- table(true_val,class_pred_probit)
#tab_class_cloglog &lt;- table(true_val,class_pred_cloglog)
  
# Compute the classification accuracy for all three models
#acc_logit &lt;- sum(diag(tab_class_logit)) / nrow(test_set)
#acc_probit &lt;- sum(diag(tab_class_probit)) / nrow(test_set)
#acc_cloglog &lt;- sum(diag(tab_class_cloglog)) / nrow(test_set)</code></pre>
</div>
<div id="computing-the-gain-for-a-tree" class="section level2">
<h2>3-2 Computing the gain for a tree</h2>
<p>In the video, you looked at how the Gini-measure is used to create the perfect split for a tree. Now, you will compute the gain for the tree loaded in your workspace.</p>
<p>The data set contains 500 cases, 89 of these cases are defaults. This led to a Gini of 0.292632 in the root node. As a small reminder, remember that Gini of a certain node = 2 * proportion of defaults in this node * proportion of non-defaults in this node. Have a look at the code for a refresher.</p>
<p>gini_root &lt;- 2 * (89 / 500) * (411 / 500)</p>
<p>You will use these Gini measures to help you calculate the gain of the leaf nodes with respect to the root node. Look at the following code to get an idea of how you can use the gini measures you created to calculate the gain of a node.</p>
<p>Gain = gini_root - (prop(cases left leaf) * gini_left) - (prop(cases right leaf * gini_right))</p>
<p>Compute the gini in the left hand and the right hand node, and the gain of the two leaf nodes with respect to the root node. The object containing the tree is small_tree.</p>
<pre class="r"><code># The Gini-measure of the root node is given below
gini_root &lt;- 2 * 89 / 500 * 411 / 500

# Compute the Gini measure for the left leaf node
gini_ll &lt;- 2 * 45 / 446 * 401 / 446

# Compute the Gini measure for the right leaf node
gini_rl &lt;- 2 * 10 / 54 * 44 / 54

# Compute the gain
gain &lt;- gini_root - 446 / 500 * gini_ll - 54 / 500 * gini_rl

# compare the gain-column in small_tree$splits with our computed gain, multiplied by 500, and assure they are the same
#small_tree$splits
improve &lt;- gain * 500</code></pre>
</div>
<div id="undersampling-the-training-set" class="section level2">
<h2>3-5 Undersampling the training set</h2>
<p>In the video, you saw that to overcome the unbalanced data problem, you can use under- or oversampling. The training set has been undersampled for you, such that 1/3 of the training set consists of defaults, and 2/3 of non-defaults. The resulting data set is available in your workspace and named undersampled_training_set, and contains less observations (6570 instead of 19394). In this exercise, you will create a decision tree using the undersampled data set.</p>
<p>You will notice that the trees in this and the next exercises are very big, so big that you cannot really read them anymore. Don’t worry about this for now, we will tell you how you can make them more manageable in the next video!</p>
<pre class="r"><code># Load package rpart in your workspace.
library(rpart)

# Change the code provided in the video such that a decision tree is constructed using the undersampled training set. Include rpart.control to relax the complexity parameter to 0.001.
tree_undersample &lt;- rpart(loan_status ~ ., method = &quot;class&quot;,
                          data =  undersampled_training_set,
                          control = rpart.control(cp = 0.001))

# Plot the decision tree
plot(tree_undersample, uniform = TRUE)

# Add labels to the decision tree
text(tree_undersample)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
<div id="changing-the-prior-probabilities" class="section level2">
<h2>3-6 Changing the prior probabilities</h2>
<p>As mentioned in the video, you can also change the prior probabilities to obtain a decision tree. This is an indirect way of adjusting the importance of misclassifications for each class. You can specify another argument inside rpart() to include prior probabities. The argument you are looking for has the following form</p>
<p>parms = list(prior=c(non_default_proportion, default_proportion))</p>
<p>The rpart package is now already loaded in your workspace.</p>
<pre class="r"><code># Change the code below such that a tree is constructed with adjusted prior probabilities.
tree_prior &lt;- rpart(loan_status ~ ., method = &quot;class&quot;,
                    data = training_set, parms = list(prior = c(0.7, 0.3)),
                    control = rpart.control(cp = 0.001))

# Plot the decision tree
plot(tree_prior, uniform = TRUE)

# Add labels to the decision tree
text(tree_prior)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
<div id="including-a-loss-matrix" class="section level2">
<h2>3-7 Including a loss matrix</h2>
<p>Thirdly, you can include a loss matrix, changing the relative importance of misclassifying a default as non-default versus a non-default as a default. You want to stress that misclassifying a default as a non-default should be penalized more heavily. Including a loss matrix can again be done in the argument parms in the loss matrix.</p>
<p>parms = list(loss = matrix(c(0, cost_def_as_nondef, cost_nondef_as_def, 0), ncol=2))
Doing this, you are constructing a 2x2-matrix with zeroes on the diagonal and changed loss penalties off-diagonal. The default loss matrix is all ones off-diagonal.</p>
<pre class="r"><code># Change the code provided in the video such that a decision tree is constructed using a loss matrix penalizing 10 times more heavily for misclassified defaults.
tree_loss_matrix  &lt;- rpart(loan_status ~ ., method = &quot;class&quot;, data = training_set,
                           parms = list(loss = matrix(c(0, 10, 1, 0), ncol = 2)),
                           control = rpart.control(cp = 0.001))

# Plot the decision tree
plot(tree_loss_matrix, uniform = TRUE)

# Add labels to the decision tree
text(tree_loss_matrix)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
</div>
<div id="pruning-the-tree-with-changed-prior-probabilities" class="section level2">
<h2>3-9 Pruning the tree with changed prior probabilities</h2>
<p>In the video, you have learned that pruning a tree is necessary to avoid overfitting. There were some big trees in the previous exercises and now you will put what you have learned into practice, and prune the previously constructed tree with the changed prior probabilities. The rpart package is already loaded in your workspace.</p>
<p>You will first set a seed to make sure the results are reproducible as mentioned in the video, because you will be examining cross-validated error results. Results involve randomness and could differ slightly upon running the function again with a different seed.</p>
<p>In this exercise you will learn to identify which complexity parameter (CP) will minimize the cross-validated error results, then prune your tree based on this value.</p>
<pre class="r"><code># tree_prior is loaded in your workspace

# Plot the cross-validated error rate as a function of the complexity parameter
plotcp(tree_prior)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<pre class="r"><code># Use printcp() to identify for which complexity parameter the cross-validated error rate is minimized.
printcp(tree_prior)</code></pre>
<pre><code>## 
## Classification tree:
## rpart(formula = loan_status ~ ., data = training_set, method = &quot;class&quot;, 
##     parms = list(prior = c(0.7, 0.3)), control = rpart.control(cp = 0.001))
## 
## Variables actually used in tree construction:
## [1] age            annual_inc     emp_cat        grade          home_ownership
## [6] ir_cat         loan_amnt     
## 
## Root node error: 8727.3/29091 = 0.3
## 
## n= 29091 
## 
##           CP nsplit rel error  xerror     xstd
## 1  0.0032569      0   1.00000 1.00000 0.016599
## 2  0.0021219      7   0.97562 0.99456 0.016027
## 3  0.0014457      8   0.97350 0.99605 0.015928
## 4  0.0014345     12   0.96729 0.99384 0.015929
## 5  0.0013200     16   0.96039 0.99386 0.015935
## 6  0.0013182     18   0.95775 0.99317 0.015926
## 7  0.0011768     20   0.95511 0.99238 0.015932
## 8  0.0011302     21   0.95393 0.99155 0.015955
## 9  0.0011178     22   0.95280 0.99153 0.015944
## 10 0.0010943     23   0.95169 0.99505 0.015932
## 11 0.0010610     24   0.95059 0.99679 0.015974
## 12 0.0010000     26   0.94847 0.99582 0.015964</code></pre>
<pre class="r"><code># Create an index for of the row with the minimum xerror
index &lt;- which.min(tree_prior$cptable[ , &quot;xerror&quot;])

# Create tree_min
tree_min &lt;- tree_prior$cptable[index, &quot;CP&quot;]

#  Prune the tree using tree_min
ptree_prior &lt;- prune(tree_prior, cp = tree_min)

# Use prp() to plot the pruned tree
prp(ptree_prior)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-23-2.png" width="672" /></p>
</div>
<div id="pruning-the-tree-with-the-loss-matrix" class="section level2">
<h2>3-10 Pruning the tree with the loss matrix</h2>
<p>In this exercise, you will prune the tree that was built using a loss matrix in order to penalize misclassified defaults more than misclassified non-defaults.</p>
<p>Looking at the cp-plot, you will notice that pruning the tree using the minimum cross-validated error will lead to a tree that is as big as the unpruned tree, as the cross-validated error reaches its minimum for cp = 0.001. Because you would like to make the tree somewhat smaller, try pruning the tree using cp = 0.0012788. For this complexity parameter, the cross-validated error approaches the minimum observed error. Call the pruned tree ptree_loss_matrix.</p>
<pre class="r"><code># set a seed and run the code to construct the tree with the loss matrix again
set.seed(345)
tree_loss_matrix  &lt;- rpart(loan_status ~ ., method = &quot;class&quot;, data = training_set,
                           parms = list(loss=matrix(c(0, 10, 1, 0), ncol = 2)),
                           control = rpart.control(cp = 0.001))

# Plot the cross-validated error rate as a function of the complexity parameter
plotcp(tree_loss_matrix) </code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code># Prune the tree using cp = 0.0012788
ptree_loss_matrix &lt;- prune(tree_loss_matrix, cp = 0.0012788)

# Use prp() and argument extra = 1 to plot the pruned tree
prp(ptree_loss_matrix, extra = 1)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-24-2.png" width="672" /></p>
</div>
<div id="one-final-tree-using-more-options" class="section level2">
<h2>3-12 One final tree using more options</h2>
<p>In this exercise, you will use some final arguments that were discussed in the video. Some specifications in the rpart.control()-function will be changed, and some weights will be included using the weights argument in rpart(). The vector case_weights has been constructed for you and is loaded in your workspace. This vector contains weights of 1 for the non-defaults in the training set, and weights of 3 for defaults in the training sets. By specifying higher weights for default, the model will assign higher importance to classifying defaults correctly.</p>
<pre class="r"><code># set a seed and run the code to obtain a tree using weights, minsplit and minbucket
set.seed(345)
tree_weights &lt;- rpart(loan_status ~ ., method = &quot;class&quot;, weights=case_weights$x, 
                      data = training_set_ch3,
                      control = rpart.control(minsplit = 5, minbucket = 2, cp = 0.001))

# Plot the cross-validated error rate for a changing cp
plotcp(tree_weights)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<pre class="r"><code># Create an index for of the row with the minimum xerror
index &lt;- which.min(tree_weights$cp[ , &quot;xerror&quot;])

# Create tree_min
tree_min &lt;- tree_weights$cp[index, &quot;CP&quot;]

# Prune the tree using tree_min
ptree_weights &lt;- prune(tree_weights, cp = tree_min)

# Plot the pruned tree using the rpart.plot()-package
prp(ptree_weights, extra = 1)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-25-2.png" width="672" /></p>
</div>
<div id="confusion-matrices-and-accuracy-of-our-final-trees" class="section level2">
<h2>3-13 Confusion matrices and accuracy of our final trees</h2>
<p>Over the past few exercises, you have constructed quite a few pruned decision trees, with four in total. As you can see, the eventual number of splits varies quite a bit from one tree to another:</p>
<p>ptree_undersample # 7 splits
ptree_prior # 9 splits
ptree_loss_matrix # 24 splits
ptree_weights # 6 splits</p>
<p>Now it is important to know which tree performs best in terms of accuracy. In order to get the accuracy, you will start off by making predictions using the test set, and construct the confusion matrix for each of these trees. You will add the argument type = “class” when doing these predictions. By doing this there is no need to set a cut-off.</p>
<p>Nevertheless, it is important to be aware of the fact that not only the accuracy is important, but also the sensitivity and specificity. Additionally, predicting probabilities instead of binary values (0 or 1) has the advantage that the cut-off can be moved along. Then again, the difficulty here is the choice of the cut-off. You will return to this in the next chapter.</p>
<p>In case you needed a reminder, here is how to compute the accuracy:</p>
<p>Classification accuracy= (TP+TN)/(TP+FP+TN+FN)</p>
<hr />
</div>
<div id="make-predictions-for-each-of-the-pruned-trees-using-the-test-set." class="section level1">
<h1>Make predictions for each of the pruned trees using the test set.</h1>
<p>pred_undersample &lt;- predict(ptree_undersample, newdata = test_set2, type = “class”)
pred_prior &lt;- predict(ptree_prior, newdata = test_set, type = “class”)
pred_loss_matrix &lt;- predict(ptree_loss_matrix, newdata = test_set, type = “class”)
pred_weights &lt;- predict(ptree_weights, newdata = test_set, type = “class”)</p>
</div>
<div id="construct-confusion-matrices-using-the-predictions." class="section level1">
<h1>Construct confusion matrices using the predictions.</h1>
<p>confmat_undersample &lt;- table(test_set<span class="math inline">\(loan_status, pred_undersample) confmat_prior &lt;- table(test_set\)</span>loan_status, pred_prior)
confmat_loss_matrix &lt;- table(test_set<span class="math inline">\(loan_status, pred_loss_matrix) confmat_weights &lt;- table(test_set\)</span>loan_status, pred_weights)</p>
</div>
<div id="compute-the-accuracies" class="section level1">
<h1>Compute the accuracies</h1>
<p>acc_undersample &lt;- sum(diag(confmat_undersample)) / nrow(test_set)
acc_prior &lt;- sum(diag(confmat_prior)) / nrow(test_set)
acc_loss_matrix &lt;- sum(diag(confmat_loss_matrix)) / nrow(test_set)
acc_weights &lt;- sum(diag(confmat_weights)) / nrow(test_set)</p>
<hr />
<div id="computing-a-bad-rate-given-a-fixed-acceptance-rate" class="section level2">
<h2>4-2 Computing a bad rate given a fixed acceptance rate</h2>
<p>In the video, you learned how to compute the bad rate (or, the percentage of defaults) in the loan portfolio of a bank when given:</p>
<p>a specific model
the acceptance rate</p>
<p>In this exercise, you will compute the bad rate that a bank can expect when using the pruned tree ptree_prior that you fitted before, and an acceptance rate of 80%. As a reminder, the tree is plotted on your right hand side.</p>
<p>Remember that if you use the predict() function for a tree, the probability of default can be found in the second column. Therefore [,2] was pasted to the predict() function.</p>
<pre class="r"><code># Make predictions for the probability of default using the pruned tree and the test set.
prob_default_prior &lt;- predict(ptree_prior, newdata = test_set2)[ ,2]

# Obtain the cutoff for acceptance rate 80%
cutoff_prior &lt;- quantile(prob_default_prior, 0.8)
  
# Obtain the binary predictions.
bin_pred_prior_80 &lt;- ifelse(prob_default_prior &gt; cutoff_prior, 1, 0)

# Obtain the actual default status for the accepted loans
accepted_status_prior_80 &lt;- test_set$loan_status[bin_pred_prior_80 == 0]

# Obtain the bad rate for the accepted loans
sum(accepted_status_prior_80) / length(accepted_status_prior_80)</code></pre>
<pre><code>## [1] 0.1117108</code></pre>
</div>
<div id="the-strategy-table-and-strategy-curve" class="section level2">
<h2>4-3 The strategy table and strategy curve</h2>
<p>Repeating the calculations you did in the previous exercise for several acceptance rates, you can obtain a strategy table. This table can be a useful tool for banks, as they can give them a better insight to define an acceptance strategy.</p>
<p>You know how to compute a bad rate for a certain acceptance rate by now, so the function strategy_bank was written and loaded into your workspace to speed things up. This function computes the cut-off and bad rate for the acceptance rates that are multiples of 5% (0%, 5%, 10%, …).</p>
<pre class="r"><code>strategy_bank &lt;- function(prob_of_def){
cutoff=rep(NA, 21)
bad_rate=rep(NA, 21)
accept_rate=seq(1,0,by=-0.05)
for (i in 1:21){
  cutoff[i]=quantile(prob_of_def,accept_rate[i])
  pred_i=ifelse(prob_of_def&gt; cutoff[i], 1, 0)
  pred_as_good=test_set$loan_status[pred_i==0]
  bad_rate[i]=sum(pred_as_good)/length(pred_as_good)}
table=cbind(accept_rate,cutoff=round(cutoff,4),bad_rate=round(bad_rate,4))
return(list(table=table,bad_rate=bad_rate, accept_rate=accept_rate, cutoff=cutoff))
}</code></pre>
<hr />
</div>
</div>
<div id="have-a-look-at-the-function-strategy_bank" class="section level1">
<h1>Have a look at the function strategy_bank</h1>
<p>strategy_bank</p>
</div>
<div id="apply-the-function-strategy_bank-to-both-predictions_cloglog-and-predictions_loss_matrix" class="section level1">
<h1>Apply the function strategy_bank to both predictions_cloglog and predictions_loss_matrix</h1>
<p>strategy_cloglog &lt;- strategy_bank(predictions_cloglog)
strategy_loss_matrix &lt;- strategy_bank(predictions_loss_matrix)</p>
</div>
<div id="obtain-the-strategy-tables-for-both-prediction-vectors" class="section level1">
<h1>Obtain the strategy tables for both prediction-vectors</h1>
<p>strategy_cloglog<span class="math inline">\(table strategy_loss_matrix\)</span>table</p>
</div>
<div id="draw-the-strategy-functions" class="section level1">
<h1>Draw the strategy functions</h1>
<p>par(mfrow = c(1,2))
plot(strategy_cloglog<span class="math inline">\(accept_rate, strategy_cloglog\)</span>bad_rate,
type = “l”, xlab = “Acceptance rate”, ylab = “Bad rate”,
lwd = 2, main = “logistic regression”)</p>
<p>plot(strategy_loss_matrix<span class="math inline">\(accept_rate, strategy_loss_matrix\)</span>bad_rate,
type = “l”, xlab = “Acceptance rate”,
ylab = “Bad rate”, lwd = 2, main = “tree”)</p>
<hr />
<div id="roc-curves-for-comparison-of-logistic-regression-models" class="section level2">
<h2>4-6 ROC-curves for comparison of logistic regression models</h2>
<p>ROC-curves can easily be created using the pROC-package in R. Let’s have a look if there is a big difference between ROC-curves for the four logistic regression-models previously used throughout this course. A small heads up:</p>
<p>predictions_logit contains probability of default (PD) predictions using the default logit link and containing variables age, emp_cat, ir_cat and loan_amnt.
predictions_probit contains PD-predictions using the probit and containing variables age, emp_cat, ir_cat and loan_amnt.
predictions_cloglog contains PD-predictions using the cloglog link and containing variables age, emp_cat, ir_cat and loan_amnt.
predictions_all_full contains PD-predictions using the default logit link and containing all seven variables in the data set.
You will first draw the ROC-curves for these four models in one plot. Afterwards, you will look at the area under the curve.</p>
<hr />
</div>
</div>
<div id="load-the-proc-package" class="section level1">
<h1>Load the pROC-package</h1>
<p>library(pROC)</p>
</div>
<div id="construct-the-objects-containing-roc-information" class="section level1">
<h1>Construct the objects containing ROC-information</h1>
<p>ROC_logit &lt;- roc(test_set<span class="math inline">\(loan_status, predictions_logit) ROC_probit &lt;- roc(test_set\)</span>loan_status, predictions_probit)
ROC_cloglog &lt;- roc(test_set<span class="math inline">\(loan_status, predictions_cloglog) ROC_all_full &lt;- roc(test_set\)</span>loan_status, predictions_all_full)</p>
</div>
<div id="draw-all-rocs-on-one-plot" class="section level1">
<h1>Draw all ROCs on one plot</h1>
<p>plot(ROC_logit)
lines(ROC_probit, col = “blue”)
lines(ROC_cloglog, col = “red”)
lines(ROC_all_full, col = “green”)</p>
</div>
<div id="compute-the-aucs" class="section level1">
<h1>Compute the AUCs</h1>
<p>auc(ROC_logit)
auc(ROC_probit)
auc(ROC_cloglog)
auc(ROC_all_full)</p>
<hr />
<div id="roc-curves-for-comparison-of-tree-based-models" class="section level2">
<h2>4-7 ROC-curves for comparison of tree-based models</h2>
<p>It’s time for you to repeat the previous exercises, now comparing the tree-based models. The pROC() is now loaded in your workspace. The PD-predictions for tree-based methods are stored in the objects</p>
<p>predictions_undersample
predictions_prior
predictions_loss_matrix
predictions_weights</p>
<hr />
</div>
</div>
<div id="construct-the-objects-containing-roc-information-1" class="section level1">
<h1>Construct the objects containing ROC-information</h1>
<p>ROC_undersample &lt;- roc(test_set<span class="math inline">\(loan_status, predictions_undersample) ROC_prior &lt;- roc(test_set\)</span>loan_status, predictions_prior)
ROC_loss_matrix &lt;- roc(test_set<span class="math inline">\(loan_status, predictions_loss_matrix) ROC_weights &lt;- roc(test_set\)</span>loan_status, predictions_weights)</p>
</div>
<div id="draw-the-roc-curves-in-one-plot" class="section level1">
<h1>Draw the ROC-curves in one plot</h1>
<p>plot(ROC_undersample)
lines(ROC_prior, col=“blue”)
lines(ROC_loss_matrix, col=“red”)
lines(ROC_weights, col=“green”)</p>
</div>
<div id="compute-the-aucs-1" class="section level1">
<h1>Compute the AUCs</h1>
<p>auc(ROC_undersample)
auc(ROC_prior)
auc(ROC_loss_matrix)
auc(ROC_weights)</p>
<hr />
<div id="another-round-of-pruning-based-on-auc" class="section level2">
<h2>4-9 Another round of pruning based on AUC</h2>
<p>In the video you saw how the “full” logistic regression model with a logit link was being pruned based on the AUC. You saw how the variable home_ownership was deleted from the model, as it improved the overall AUC. After repeating this process for two additional rounds, the variables age and ir_cat were deleted, leading to the model:</p>
<p>log_3_remove_ir &lt;- glm(loan_status ~ loan_amnt + grade + annual_inc + emp_cat, family = binomial, data = training_set)
with an AUC of 0.6545. Now, it’s your turn to see whether the AUC can still be improved by deleting another variable from the model.</p>
<hr />
</div>
</div>
<div id="build-four-models-each-time-deleting-one-variable-in-log_3_remove_ir" class="section level1">
<h1>Build four models each time deleting one variable in log_3_remove_ir</h1>
<p>log_4_remove_amnt &lt;- glm(loan_status ~ grade + annual_inc + emp_cat,
family = binomial, data = training_set)
log_4_remove_grade &lt;- glm(loan_status ~ loan_amnt + annual_inc + emp_cat,
family = binomial, data = training_set)
log_4_remove_inc &lt;- glm(loan_status ~ loan_amnt + grade + emp_cat ,
family = binomial, data = training_set)
log_4_remove_emp &lt;- glm(loan_status ~ loan_amnt + grade + annual_inc,
family = binomial, data = training_set)</p>
</div>
<div id="make-pd-predictions-for-each-of-the-models" class="section level1">
<h1>Make PD-predictions for each of the models</h1>
<p>pred_4_remove_amnt &lt;- predict(log_4_remove_amnt, newdata = test_set, type = “response”)
pred_4_remove_grade &lt;- predict(log_4_remove_grade, newdata = test_set, type = “response”)
pred_4_remove_inc &lt;- predict(log_4_remove_inc, newdata = test_set, type = “response”)
pred_4_remove_emp &lt;- predict(log_4_remove_emp, newdata = test_set, type = “response”)</p>
</div>
<div id="compute-the-aucs-2" class="section level1">
<h1>Compute the AUCs</h1>
<p>auc(test_set<span class="math inline">\(loan_status, pred_4_remove_amnt) auc(test_set\)</span>loan_status, pred_4_remove_grade)
auc(test_set<span class="math inline">\(loan_status, pred_4_remove_inc) auc(test_set\)</span>loan_status, pred_4_remove_emp)</p>
<hr />
<div id="further-model-reduction" class="section level2">
<h2>4-11 Further model reduction?</h2>
<p>Deleting the variable loan_amnt, the AUC can be further improved to 0.6548! The resulting model is</p>
<p>log_4_remove_amnt &lt;- glm(loan_status ~ grade + annual_inc + emp_cat, family = binomial, data = training_set)
Is it possible to reduce the logistic regression model to only two variable without reducing the AUC? In this exercise you will see if it is possible!</p>
<hr />
</div>
</div>
<div id="build-three-models-each-time-deleting-one-variable-in-log_4_remove_amnt" class="section level1">
<h1>Build three models each time deleting one variable in log_4_remove_amnt</h1>
<p>log_5_remove_grade &lt;- glm(loan_status ~ annual_inc + emp_cat, family = binomial, data = training_set)<br />
log_5_remove_inc &lt;- glm(loan_status ~ grade + emp_cat , family = binomial, data = training_set)
log_5_remove_emp &lt;- glm(loan_status ~ grade + annual_inc, family = binomial, data = training_set)</p>
</div>
<div id="make-pd-predictions-for-each-of-the-models-1" class="section level1">
<h1>Make PD-predictions for each of the models</h1>
<p>pred_5_remove_grade &lt;- predict(log_5_remove_grade, newdata = test_set, type = “response”)
pred_5_remove_inc &lt;- predict(log_5_remove_inc, newdata = test_set, type = “response”)
pred_5_remove_emp &lt;- predict(log_5_remove_emp, newdata = test_set, type = “response”)</p>
</div>
<div id="compute-the-aucs-3" class="section level1">
<h1>Compute the AUCs</h1>
<p>auc(test_set<span class="math inline">\(loan_status, pred_5_remove_grade) auc(test_set\)</span>loan_status, pred_5_remove_inc)
auc(test_set$loan_status, pred_5_remove_emp)</p>
</div>
<div id="plot-the-roc-curve-for-the-best-model-here" class="section level1">
<h1>Plot the ROC-curve for the best model here</h1>
<p>plot(roc(test_set$loan_status,pred_4_remove_amnt))</p>
<hr />
</div>
