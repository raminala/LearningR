---
title: Credit Risk Modeling in R
author: ''
date: '2021-09-22'
slug: credit-risk-modeling-in-r
categories: []
tags:
  - logistic regression
  - decision trees
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>This hands-on-course with real-life credit data will teach you how to model credit risk by using logistic regression and decision trees in R.</p>
<p>Modeling credit risk for both personal and company loans is of major importance for banks. The probability that a debtor will default is a key component in getting to a measure for credit risk. While other models will be introduced in this course as well, you will learn about two model types that are often used in the credit scoring context; logistic regression and decision trees. You will learn how to use them in this particular context, and how these models are evaluated by banks.</p>
<div id="exploring-the-credit-data" class="section level2">
<h2>1-2 Exploring the credit data</h2>
<p>We will be examining the dataset loan_data discussed in the video throughout the exercises in this course.</p>
<p>After being given loan_data, you are particularly interested about the defaulted loans in the data set. You want to get an idea of the number, and percentage of defaults. Defaults are rare, so you always want to check what the proportion of defaults is in a loan dataset. The CrossTable() function is very useful here.</p>
<p>Remember that default information is stored in the response variable loan_status, where 1 represents a default, and 0 represents non-default.</p>
<p>To learn more about variable structures and spot unexpected tendencies in the data, you should examine the relationship between loan_status and certain factor variables. For example, you would expect that the proportion of defaults in the group of customers with grade G (worst credit rating score) is substantially higher than the proportion of defaults in the grade A group (best credit rating score).</p>
<p>Conveniently, CrossTable() can also be applied on two categorical variables. Let’s explore!</p>
<pre class="r"><code># View the structure of loan_data
str(loan_data)</code></pre>
<pre><code>## &#39;data.frame&#39;:    29092 obs. of  8 variables:
##  $ loan_status   : int  0 0 0 0 0 0 1 0 1 0 ...
##  $ loan_amnt     : int  5000 2400 10000 5000 3000 12000 9000 3000 10000 1000 ...
##  $ int_rate      : num  10.6 NA 13.5 NA NA ...
##  $ grade         : Factor w/ 7 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 2 3 3 1 5 2 3 2 2 4 ...
##  $ emp_length    : int  10 25 13 3 9 11 0 3 3 0 ...
##  $ home_ownership: Factor w/ 4 levels &quot;MORTGAGE&quot;,&quot;OTHER&quot;,..: 4 4 4 4 4 3 4 4 4 4 ...
##  $ annual_inc    : num  24000 12252 49200 36000 48000 ...
##  $ age           : int  33 31 24 39 24 28 22 22 28 22 ...</code></pre>
<pre class="r"><code># Call CrossTable() on loan_status
CrossTable(loan_data$loan_status)</code></pre>
<pre><code>## 
##  
##    Cell Contents
## |-------------------------|
## |                       N |
## |         N / Table Total |
## |-------------------------|
## 
##  
## Total Observations in Table:  29092 
## 
##  
##           |         0 |         1 | 
##           |-----------|-----------|
##           |     25865 |      3227 | 
##           |     0.889 |     0.111 | 
##           |-----------|-----------|
## 
## 
## 
## </code></pre>
<pre class="r"><code># Call CrossTable() on grade and loan_status
CrossTable(loan_data$grade, loan_data$loan_status, prop.r = TRUE, prop.c = FALSE, prop.t = FALSE, prop.chisq = FALSE)</code></pre>
<pre><code>## 
##  
##    Cell Contents
## |-------------------------|
## |                       N |
## |           N / Row Total |
## |-------------------------|
## 
##  
## Total Observations in Table:  29092 
## 
##  
##                 | loan_data$loan_status 
## loan_data$grade |         0 |         1 | Row Total | 
## ----------------|-----------|-----------|-----------|
##               A |      9084 |       565 |      9649 | 
##                 |     0.941 |     0.059 |     0.332 | 
## ----------------|-----------|-----------|-----------|
##               B |      8344 |       985 |      9329 | 
##                 |     0.894 |     0.106 |     0.321 | 
## ----------------|-----------|-----------|-----------|
##               C |      4904 |       844 |      5748 | 
##                 |     0.853 |     0.147 |     0.198 | 
## ----------------|-----------|-----------|-----------|
##               D |      2651 |       580 |      3231 | 
##                 |     0.820 |     0.180 |     0.111 | 
## ----------------|-----------|-----------|-----------|
##               E |       692 |       176 |       868 | 
##                 |     0.797 |     0.203 |     0.030 | 
## ----------------|-----------|-----------|-----------|
##               F |       155 |        56 |       211 | 
##                 |     0.735 |     0.265 |     0.007 | 
## ----------------|-----------|-----------|-----------|
##               G |        35 |        21 |        56 | 
##                 |     0.625 |     0.375 |     0.002 | 
## ----------------|-----------|-----------|-----------|
##    Column Total |     25865 |      3227 |     29092 | 
## ----------------|-----------|-----------|-----------|
## 
## </code></pre>
</div>
<div id="histograms" class="section level2">
<h2>1-5 Histograms</h2>
<p>The data set loan_data is loaded in your workspace. You previously explored categorical variables using the CrossTable() function. Now you would like to explore continuous variables to identify potential outliers or unexpected data structures.</p>
<p>To do this, let’s experiment with the function hist() to understand the distribution of the number of loans for different customers.</p>
<pre class="r"><code>loan_data %&gt;% ggplot(aes(loan_amnt))+ geom_histogram(bins = 30)+
  labs(x = &quot;Loan amount&quot;, title = &quot;Histogram of the loan amount&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="outliers" class="section level2">
<h2>1-6 Outliers</h2>
<p>Now it’s time to look at the structure of the variable age. A histogram is plotted on your right. Similar to what you observed in the video for annual income (annual_inc), there is a lot of blank space on the right-hand side of the plot. This is an indication of possible outliers. You will look at a scatterplot to verify this. If you find any outliers you will delete them.</p>
<p>If outliers are observed for several variables, it might be useful to look at bivariate plots. It’s possible the outliers belong to the same observation. If so, there is even more reason to delete the observation because it is more likely that some information stored in it is wrong.</p>
<pre class="r"><code># Plot the age variable
loan_data %&gt;% ggplot(aes(as.numeric(rownames(loan_data)), age))+ geom_point()+
  labs(x=&quot;Index&quot;, y = &quot;Age&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># Save the outlier&#39;s index to index_highage
index_highage &lt;- which(loan_data$age &gt; 122)

# Create data set new_data with outlier deleted
new_data &lt;- loan_data[-index_highage, ]

# Make bivariate scatterplot of age and annual income

loan_data %&gt;% ggplot(aes(age, annual_inc))+ geom_point()+
  labs(x=&quot;Age&quot;, y = &quot;Annual Income&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-2.png" width="672" /></p>
</div>
<div id="deleting-missing-data" class="section level2">
<h2>1-8 Deleting missing data</h2>
<p>You saw before that the interest rate (int_rate) in the data set loan_data depends on the customer. Unfortunately some observations are missing interest rates. You now need to identify how many interest rates are missing and then delete them.</p>
<p>In this exercise you will use the function which() to create an index of rows that contain an NA. You will then use this index to delete rows with NAs.</p>
<pre class="r"><code>library(naniar)
vis_miss(loan_data)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code># Look at summary of loan_data
 summary(loan_data$int_rate)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##    5.42    7.90   10.99   11.00   13.47   23.22    2776</code></pre>
<pre class="r"><code># Get indices of missing interest rates: na_index
na_index &lt;- which(is.na(loan_data$int_rate))

# Remove observations with missing interest rates: loan_data_delrow_na
loan_data_delrow_na &lt;- loan_data[-na_index, ]

# Make copy of loan_data
loan_data_delcol_na &lt;- loan_data

# Delete interest rate column from loan_data_delcol_na
loan_data_delcol_na$int_rate &lt;- NULL</code></pre>
</div>
<div id="replacing-missing-data" class="section level2">
<h2>1-9 Replacing missing data</h2>
<p>Rather than deleting the missing interest rates, you may want to replace them instead. The object na_index, which contains the index of the observations with missing interest rates is still loaded in your workspace.</p>
<pre class="r"><code># Compute the median of int_rate
median_ir &lt;- median(loan_data$int_rate, na.rm=TRUE)

# Make copy of loan_data
loan_data_replace &lt;- loan_data

# Replace missing interest rates with median
loan_data_replace$int_rate[which(is.na(loan_data$int_rate))] &lt;- median_ir

# Check if the NAs are gone
summary(loan_data_replace$int_rate)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    5.42    8.49   10.99   11.00   13.11   23.22</code></pre>
</div>
<div id="keeping-missing-data" class="section level2">
<h2>1-10 Keeping missing data</h2>
<p>In some situations, the fact that an input is missing is important information in itself. NAs can be kept in a separate “missing” category using coarse classification.</p>
<p>Coarse classification allows you to simplify your data and improve the interpretability of your model. Coarse classification requires you to bin your responses into groups that contain ranges of values. You can use this binning technique to place all NAs in their own bin.</p>
<p>In the video, we illustrated the idea of coarse classification for employment length. The code from that example has been reproduced in the R script to the right and can be adapted to coarse classify the int_rate variable.</p>
<pre class="r"><code># Make the necessary replacements in the coarse classification example below 
loan_data$ir_cat &lt;- rep(NA, length(loan_data$int_rate))

loan_data$ir_cat[which(loan_data$int_rate &lt;= 8)] &lt;- &quot;0-8&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 8 &amp; loan_data$int_rate &lt;= 11)] &lt;- &quot;8-11&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 11 &amp; loan_data$int_rate &lt;= 13.5)] &lt;- &quot;11-13.5&quot;
loan_data$ir_cat[which(loan_data$int_rate &gt; 13.5)] &lt;- &quot;13.5+&quot;
loan_data$ir_cat[which(is.na(loan_data$int_rate))] &lt;- &quot;Missing&quot;

loan_data$ir_cat &lt;- as.factor(loan_data$ir_cat)

# Look at your new variable using plot()
plot(loan_data$ir_cat)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="splitting-the-data-set" class="section level2">
<h2>1-12 Splitting the data set</h2>
<p>To make your training and test sets, you should first set a seed using set.seed(). Seeds allow you to create a starting point for randomly generated numbers, so that each time your code is run the same answer is generated. The advantage of doing this in your sampling is that you or anyone else can recreate the exact same training and test sets by using the same seed.</p>
<p>Using sample(), you can randomly assign observations to the training and test set.</p>
<p>For this exercise you will use the two first arguments in the sample() function:</p>
<p>The first argument is the vector from which we will sample values. We will randomly pick row numbers as indices; you can use 1:nrow(loan_data) to create the vector of row numbers.
The second argument is the number of items to choose. We will enter 2 / 3 * nrow(loan_data), as we construct the training set first.</p>
<pre class="r"><code># Set seed of 567
set.seed(567)

# Store row numbers for training set: index_train
index_train &lt;- sample(1:nrow(loan_data), 2 / 3 * nrow(loan_data))

# Create training set: training_set
training_set &lt;- loan_data[index_train, ]

# Create test set: test_set
test_set &lt;- loan_data[-index_train, ]</code></pre>
</div>
<div id="creating-a-confusion-matrix" class="section level2">
<h2>1-13 Creating a confusion matrix</h2>
<p>In this example, assume that you have run a model and stored the predicted outcomes in a vector called model_pred. You want to see how the model performed so you will construct a confusion matrix. You will compare the actual loan status column (loan_status) to the predicted values (model_pred), using the table() function, where the arguments are the true values and the predicted values. Recall the confusion matrix structure:</p>
<div class="figure">
<img src="1.JPG" alt="" />
<p class="caption">Caption for the picture.</p>
</div>
</div>
