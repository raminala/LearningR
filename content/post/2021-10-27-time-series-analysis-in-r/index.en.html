---
title: Time Series Analysis in R
author: ''
date: '2021-10-27'
slug: time-series-analysis-in-r
categories: []
tags:
  - Time Series
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<pre class="r"><code> library(tidyverse)</code></pre>
<pre><code>## -- Attaching packages --------------------------------------- tidyverse 1.3.1 --</code></pre>
<pre><code>## v ggplot2 3.3.3     v purrr   0.3.4
## v tibble  3.1.2     v dplyr   1.0.6
## v tidyr   1.1.3     v stringr 1.4.0
## v readr   1.4.0     v forcats 0.5.1</code></pre>
<pre><code>## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>Nile &lt;- ts(read.csv(&quot;Nile.csv&quot;), start = 1871 , end = 1970, frequency = 1)
class(Nile)</code></pre>
<pre><code>## [1] &quot;ts&quot;</code></pre>
<div id="course-description" class="section level2">
<h2>Course Description</h2>
<p>Many phenomena in our day-to-day lives, such as the movement of stock prices, are measured in intervals over a period of time. Time series analysis methods are extremely useful for analyzing these special data types. In this course, you will be introduced to some core time series analysis concepts and techniques.</p>
</div>
<div id="exploratory-time-series-data-analysis" class="section level2">
<h2>1- Exploratory time series data analysis</h2>
<p>This chapter will give you insights on how to organize and visualize time series data in R. You will learn several simplifying assumptions that are widely used in time series analysis, and common characteristics of financial time series.</p>
</div>
<div id="exploring-raw-time-series" class="section level2">
<h2>1-2 Exploring raw time series</h2>
<p>The most common first step when conducting time series analysis is to display your time series dataset in a visually intuitive format. The most useful way to view raw time series data in R is to use the print() command, which displays the Start, End, and Frequency of your data along with the observations.</p>
<p>Another useful command for viewing time series data in R is the length() function, which tells you the total number of observations in your data.</p>
<p>Some datasets are very long, and previewing a subset of data is more suitable than displaying the entire series. The head(<strong><em>, n =</em></strong>) and tail(<strong><em>, n =</em></strong>) functions, in which n is the number of items to display, focus on the first and last few elements of a given dataset respectively.</p>
<p>In this exercise, you’ll explore the famous River Nile annual streamflow data, Nile. This time series dataset includes some metadata information. When calling print(Nile), note that Start = 1871 indicates that 1871 is the year of the first annual observation, and End = 1970 indicates 1970 is the year of the last annual observation.</p>
<pre class="r"><code># Print the Nile dataset
print(Nile)</code></pre>
<pre><code>## Time Series:
## Start = 1871 
## End = 1970 
## Frequency = 1 
##           x
##   [1,] 1120
##   [2,] 1160
##   [3,]  963
##   [4,] 1210
##   [5,] 1160
##   [6,] 1160
##   [7,]  813
##   [8,] 1230
##   [9,] 1370
##  [10,] 1140
##  [11,]  995
##  [12,]  935
##  [13,] 1110
##  [14,]  994
##  [15,] 1020
##  [16,]  960
##  [17,] 1180
##  [18,]  799
##  [19,]  958
##  [20,] 1140
##  [21,] 1100
##  [22,] 1210
##  [23,] 1150
##  [24,] 1250
##  [25,] 1260
##  [26,] 1220
##  [27,] 1030
##  [28,] 1100
##  [29,]  774
##  [30,]  840
##  [31,]  874
##  [32,]  694
##  [33,]  940
##  [34,]  833
##  [35,]  701
##  [36,]  916
##  [37,]  692
##  [38,] 1020
##  [39,] 1050
##  [40,]  969
##  [41,]  831
##  [42,]  726
##  [43,]  456
##  [44,]  824
##  [45,]  702
##  [46,] 1120
##  [47,] 1100
##  [48,]  832
##  [49,]  764
##  [50,]  821
##  [51,]  768
##  [52,]  845
##  [53,]  864
##  [54,]  862
##  [55,]  698
##  [56,]  845
##  [57,]  744
##  [58,]  796
##  [59,] 1040
##  [60,]  759
##  [61,]  781
##  [62,]  865
##  [63,]  845
##  [64,]  944
##  [65,]  984
##  [66,]  897
##  [67,]  822
##  [68,] 1010
##  [69,]  771
##  [70,]  676
##  [71,]  649
##  [72,]  846
##  [73,]  812
##  [74,]  742
##  [75,]  801
##  [76,] 1040
##  [77,]  860
##  [78,]  874
##  [79,]  848
##  [80,]  890
##  [81,]  744
##  [82,]  749
##  [83,]  838
##  [84,] 1050
##  [85,]  918
##  [86,]  986
##  [87,]  797
##  [88,]  923
##  [89,]  975
##  [90,]  815
##  [91,] 1020
##  [92,]  906
##  [93,]  901
##  [94,] 1170
##  [95,]  912
##  [96,]  746
##  [97,]  919
##  [98,]  718
##  [99,]  714
## [100,]  740</code></pre>
<pre class="r"><code># List the number of observations in the Nile dataset
length(Nile)</code></pre>
<pre><code>## [1] 100</code></pre>
<pre class="r"><code># Display the first 10 elements of the Nile dataset
head(Nile, n=10)</code></pre>
<pre><code>##          x
##  [1,] 1120
##  [2,] 1160
##  [3,]  963
##  [4,] 1210
##  [5,] 1160
##  [6,] 1160
##  [7,]  813
##  [8,] 1230
##  [9,] 1370
## [10,] 1140</code></pre>
<pre class="r"><code># Display the last 12 elements of the Nile dataset
tail(Nile, n=12)</code></pre>
<pre><code>##          x
##  [1,]  975
##  [2,]  815
##  [3,] 1020
##  [4,]  906
##  [5,]  901
##  [6,] 1170
##  [7,]  912
##  [8,]  746
##  [9,]  919
## [10,]  718
## [11,]  714
## [12,]  740</code></pre>
</div>
<div id="basic-time-series-plots" class="section level2">
<h2>1-3 Basic time series plots</h2>
<p>While simple commands such as print(), length(), head(), and tail() provide crucial information about your time series data, another very useful way to explore any data is to generate a plot.</p>
<p>In this exercise, you will plot the River Nile annual streamflow data using the plot() function. For time series data objects such as Nile, a Time index for the horizontal axis is typically included. From the previous exercise, you know that this data spans from 1871 to 1970, and horizontal tick marks are labeled as such. The default label of “Time” is not very informative. Since these data are annual measurements, you should use the label “Year”. While you’re at it, you should change the vertical axis label to “River Volume (1e9 m^{3})”.</p>
<p>Additionally, it helps to have an informative title, which can be set using the argument main. For your purposes, a useful title for this figure would be “Annual River Nile Volume at Aswan, 1871-1970”.</p>
<p>Finally, the default plotting type for time series objects is “l” for line. Connecting consecutive observations can help make a time series plot more interpretable. Sometimes it is also useful to include both the observations points as well as the lines, and we instead use “b” for both.</p>
<pre class="r"><code># Plot the Nile data
plot(Nile )</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code># Plot the Nile data with xlab and ylab arguments
plot(Nile , xlab = &quot;Year&quot;, ylab = &quot;River Volume (1e9 m^{3})&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-2.png" width="672" /></p>
<pre class="r"><code># Plot the Nile data with xlab, ylab, main, and type arguments
plot(Nile , xlab = &quot;Year&quot;, ylab = &quot;River Volume (1e9 m^{3})&quot;, main = &quot;Annual River Nile Volume at Aswan, 1871-1970&quot;, type =&quot;b&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-3.png" width="672" /></p>
</div>
<div id="what-does-the-time-index-tell-us" class="section level2">
<h2>1-4 What does the time index tell us?</h2>
<p>Some data are naturally evenly spaced by time. The time series discrete_data shown in the top figure has 20 observations, with one observation appearing at each of the discrete time indices 1 through 20. Discrete time indexing is appropriate for discrete_data.</p>
<p>The time series continuous_series shown in the bottom figure also has 20 observations, it is following the same periodic pattern as discrete_data, but its observations are not evenly spaced. Its first, second, and last observations were observed at times 1.210322, 1.746137, and 20.180524, respectively. Continuous time indexing is natural for continuous_series, however, the observations are approximately evenly spaced, with about 1 observation observed per time unit. Let’s investigate using a discrete time indexing for continuous_series.</p>
<pre class="r"><code>continuous_time_index &lt;- c(1.210322, 1.746137, 2.889634, 3.591384, 5.462065, 5.510933, 7.074295, 8.264398, 9.373382, 9.541063, 11.161122, 12.378371, 13.390559, 14.066280, 15.093547, 15.864515, 16.857413, 18.091457, 19.365451, 20.180524)

continuous_series &lt;- c(0.56889468  , 0.76630408, 0.99207512, 0.97481741, 0.39912320, 0.37660246, -0.38532033, -0.83635852, -0.99966983, -0.99831019, -0.64622280, -0.09386151, 0.40052909, 0.68160578, 0.95318159,0.99693803, 0.83934194, 0.37003754, -0.25509676, -0.61743983)

# Plot the continuous_series using continuous time indexing
par(mfrow=c(2,1))
plot(continuous_time_index,continuous_series, type = &quot;b&quot;)

# Make a discrete time index using 1:20 
discrete_time_index &lt;- 1:20 

# Now plot the continuous_series using discrete time indexing
plot(discrete_time_index,continuous_series, type = &quot;b&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<div id="identifying-the-sampling-frequency" class="section level2">
<h2>1-6 Identifying the sampling frequency</h2>
<p>In addition to viewing your data and plotting over time, there are several additional operations that can be performed on time series datasets.</p>
<p>The start() and end() functions return the time index of the first and last observations, respectively. The time() function calculates a vector of time indices, with one element for each time index on which the series was observed.</p>
<p>The deltat() function returns the fixed time interval between observations and the frequency() function returns the number of observations per unit time. Finally, the cycle() function returns the position in the cycle of each observation.</p>
<p>In this exercise, you’ll practice applying these functions to the AirPassengers dataset, which reports the monthly total international airline passengers (in thousands) from 1949 to 1960.</p>
<pre class="r"><code>head(AirPassengers,3)</code></pre>
<pre><code>## [1] 112 118 132</code></pre>
<pre class="r"><code>class(AirPassengers)</code></pre>
<pre><code>## [1] &quot;ts&quot;</code></pre>
<pre class="r"><code># Plot AirPassengers
plot(AirPassengers)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code># View the start and end dates of AirPassengers
start(AirPassengers)</code></pre>
<pre><code>## [1] 1949    1</code></pre>
<pre class="r"><code>end(AirPassengers)</code></pre>
<pre><code>## [1] 1960   12</code></pre>
<pre class="r"><code># Use time(), deltat(), frequency(), and cycle() with AirPassengers 
time(AirPassengers)</code></pre>
<pre><code>##           Jan      Feb      Mar      Apr      May      Jun      Jul      Aug
## 1949 1949.000 1949.083 1949.167 1949.250 1949.333 1949.417 1949.500 1949.583
## 1950 1950.000 1950.083 1950.167 1950.250 1950.333 1950.417 1950.500 1950.583
## 1951 1951.000 1951.083 1951.167 1951.250 1951.333 1951.417 1951.500 1951.583
## 1952 1952.000 1952.083 1952.167 1952.250 1952.333 1952.417 1952.500 1952.583
## 1953 1953.000 1953.083 1953.167 1953.250 1953.333 1953.417 1953.500 1953.583
## 1954 1954.000 1954.083 1954.167 1954.250 1954.333 1954.417 1954.500 1954.583
## 1955 1955.000 1955.083 1955.167 1955.250 1955.333 1955.417 1955.500 1955.583
## 1956 1956.000 1956.083 1956.167 1956.250 1956.333 1956.417 1956.500 1956.583
## 1957 1957.000 1957.083 1957.167 1957.250 1957.333 1957.417 1957.500 1957.583
## 1958 1958.000 1958.083 1958.167 1958.250 1958.333 1958.417 1958.500 1958.583
## 1959 1959.000 1959.083 1959.167 1959.250 1959.333 1959.417 1959.500 1959.583
## 1960 1960.000 1960.083 1960.167 1960.250 1960.333 1960.417 1960.500 1960.583
##           Sep      Oct      Nov      Dec
## 1949 1949.667 1949.750 1949.833 1949.917
## 1950 1950.667 1950.750 1950.833 1950.917
## 1951 1951.667 1951.750 1951.833 1951.917
## 1952 1952.667 1952.750 1952.833 1952.917
## 1953 1953.667 1953.750 1953.833 1953.917
## 1954 1954.667 1954.750 1954.833 1954.917
## 1955 1955.667 1955.750 1955.833 1955.917
## 1956 1956.667 1956.750 1956.833 1956.917
## 1957 1957.667 1957.750 1957.833 1957.917
## 1958 1958.667 1958.750 1958.833 1958.917
## 1959 1959.667 1959.750 1959.833 1959.917
## 1960 1960.667 1960.750 1960.833 1960.917</code></pre>
<pre class="r"><code>deltat(AirPassengers)</code></pre>
<pre><code>## [1] 0.08333333</code></pre>
<pre class="r"><code>frequency(AirPassengers)</code></pre>
<pre><code>## [1] 12</code></pre>
<pre class="r"><code>cycle(AirPassengers)</code></pre>
<pre><code>##      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
## 1949   1   2   3   4   5   6   7   8   9  10  11  12
## 1950   1   2   3   4   5   6   7   8   9  10  11  12
## 1951   1   2   3   4   5   6   7   8   9  10  11  12
## 1952   1   2   3   4   5   6   7   8   9  10  11  12
## 1953   1   2   3   4   5   6   7   8   9  10  11  12
## 1954   1   2   3   4   5   6   7   8   9  10  11  12
## 1955   1   2   3   4   5   6   7   8   9  10  11  12
## 1956   1   2   3   4   5   6   7   8   9  10  11  12
## 1957   1   2   3   4   5   6   7   8   9  10  11  12
## 1958   1   2   3   4   5   6   7   8   9  10  11  12
## 1959   1   2   3   4   5   6   7   8   9  10  11  12
## 1960   1   2   3   4   5   6   7   8   9  10  11  12</code></pre>
</div>
<div id="missing-values" class="section level2">
<h2>1-8 Missing values</h2>
<p>Sometimes there are missing values in time series data, denoted NA in R, and it is useful to know their locations. It is also important to know how missing values are handled by various R functions. Sometimes we may want to ignore any missingness, but other times we may wish to impute or estimate the missing values.</p>
<p>Let’s again consider the monthly AirPassengers dataset, but now the data for the year 1956 are missing. In this exercise, you’ll explore the implications of this missing data and impute some new data to solve the problem.</p>
<p>The mean() function calculates the sample mean, but it fails in the presence of any NA values. Use mean(___, na.rm = TRUE) to calculate the mean with all missing values removed. It is common to replace missing values with the mean of the observed values. Does this simple data imputation scheme appear adequate when applied the the AirPassengers dataset?</p>
<pre class="r"><code># Plot the AirPassengers data
plot(AirPassengers)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code># Compute the mean of AirPassengers
mean(AirPassengers, na.rm=TRUE)</code></pre>
<pre><code>## [1] 280.2986</code></pre>
<pre class="r"><code># Impute mean values to NA in AirPassengers
AirPassengers[85:96] &lt;- mean(AirPassengers, na.rm = TRUE)

# Generate another plot of AirPassengers
plot(AirPassengers)

# Add the complete AirPassengers data to your plot
rm(AirPassengers)
points(AirPassengers, type = &quot;l&quot;, col = 2, lty = 3)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
</div>
<div id="creating-a-time-series-object-with-ts" class="section level2">
<h2>1-10 Creating a time series object with ts()</h2>
<p>The function ts() can be applied to create time series objects. A time series object is a vector (univariate) or matrix (multivariate) with additional attributes, including time indices for each observation, the sampling frequency and time increment between observations, and the cycle length for periodic data. Such objects are of the ts class, and represent data that has been observed at (approximately) equally spaced time points. Now you will create time series objects yourself.</p>
<p>The advantage of creating and working with time series objects of the ts class is that many methods are available for utilizing time series attributes, such as time index information. For example, as you’ve seen in earlier exercises, calling plot() on a ts object will automatically generate a plot over time.</p>
<p>In this exercise, you’ll familiarize yourself with the ts class by encoding some time series data (saved as data_vector) into ts and exploring the result. Your time series data_vector starts in the year 2004 and has 4 observations per year (i.e. it is quarterly data).</p>
</div>
<div id="testing-whether-an-object-is-a-time-series" class="section level2">
<h2>1-11 Testing whether an object is a time series</h2>
<p>When you work to create your own datasets, you can build them as ts objects. Recall the dataset data_vector from the previous exercise, which was just a vector of numbers, and time_series, the ts object you created from data_vector using the ts() function and information regarding the start time and the observation frequency. As a reminder, data_vector and time_series are shown in the plot on the right.</p>
<p>When you use datasets from others, such as those included in an R package, you can check whether they are ts objects using the is.ts() command. The result of the test is either TRUE when the data is of the ts class, or FALSE if it is not.</p>
<p>In this exercise, you’ll explore the class of the datasets you’ve been using throughout this chapter.</p>
</div>
<div id="plotting-a-time-series-object" class="section level2">
<h2>1-12 Plotting a time series object</h2>
<p>It is often very useful to plot data we are analyzing, as is the case when conducting time series analysis. If the dataset under study is of the ts class, then the plot() function has methods that automatically incorporate time index information into a figure.</p>
<p>Let’s consider the eu_stocks dataset (available in R by default as EuStockMarkets). This dataset contains daily closing prices of major European stock indices from 1991-1998, specifically, from Germany (DAX), Switzerland (SMI), France (CAC), and the UK (FTSE). The data were observed when the markets were open, so there are no observations on weekends and holidays. We will proceed with the approximation that this dataset has evenly spaced observations and is a four dimensional time series.</p>
<p>To conclude this chapter, this exercise asks you to apply several of the functions you’ve already learned to this new dataset.</p>
</div>
<div id="predicting-the-future" class="section level2">
<h2>2- Predicting the future</h2>
<p>In this chapter, you will conduct some trend spotting, and learn the white noise (WN) model, the random walk (RW) model, and the definition of stationary processes.</p>
</div>
<div id="correlation-analysis-and-the-autocorrelation-function" class="section level2">
<h2>3- Correlation analysis and the autocorrelation function</h2>
<p>In this chapter, you will review the correlation coefficient, use it to compare two time series, and also apply it to compare a time series with its past, as an autocorrelation. You will discover the autocorrelation function (ACF) and practice estimating and visualizing autocorrelations for time series data.</p>
</div>
<div id="autoregression" class="section level2">
<h2>4- Autoregression</h2>
<p>In this chapter, you will learn the autoregressive (AR) model and several of its basic properties. You will also practice simulating and estimating the AR model in R, and compare the AR model with the random walk (RW) model.</p>
</div>
<div id="a-simple-moving-average" class="section level2">
<h2>5- A simple moving average</h2>
<p>In this chapter, you will learn the simple moving average (MA) model and several of its basic properties. You will also practice simulating and estimating the MA model in R, and compare the MA model with the autoregressive (AR) model.</p>
<pre class="r"><code>library(tidyverse)
e &lt;- read.csv(&quot;e2.csv&quot;)
names(e)</code></pre>
<pre><code>## [1] &quot;Last.Name&quot;  &quot;First.Name&quot; &quot;Quiz.1..20&quot; &quot;Quiz.2..20&quot; &quot;Quiz.3..15&quot;
## [6] &quot;Lab.1...10&quot; &quot;Lab.2...10&quot;</code></pre>
<pre class="r"><code>e %&gt;%  pivot_longer(c(Lab.1...10,Lab.2...10)) %&gt;% 
  ggplot(aes(value,color=name))+geom_density()</code></pre>
<pre><code>## Warning: Removed 13 rows containing non-finite values (stat_density).</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>e %&gt;% mutate(q3=Quiz.3..15*20/15) %&gt;% pivot_longer(c(Quiz.1..20,Quiz.2..20,q3)) %&gt;% 
  ggplot(aes(value,color=name))+geom_density()</code></pre>
<pre><code>## Warning: Removed 23 rows containing non-finite values (stat_density).</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>Q1_m &lt;- 5*mean(e$Quiz.1..20, na.rm=TRUE)
print(paste(&quot;quiz 1: &quot;,Q1_m))</code></pre>
<pre><code>## [1] &quot;quiz 1:  57.8483606557377&quot;</code></pre>
<pre class="r"><code>Q2_m &lt;- 5*mean(e$Quiz.2..20, na.rm=TRUE)
print(paste(&quot;quiz 2: &quot;,Q2_m))</code></pre>
<pre><code>## [1] &quot;quiz 2:  70.375&quot;</code></pre>
<pre class="r"><code>Q3_m &lt;- 5*20/15*mean(e$Quiz.3..15, na.rm=TRUE)
print(paste(&quot;quiz 2: &quot;,Q3_m))</code></pre>
<pre><code>## [1] &quot;quiz 2:  79.7354497354497&quot;</code></pre>
<pre class="r"><code>Q1_max &lt;- min(e$Quiz.1..20, na.rm=TRUE)
print(paste(&quot;quiz 1: &quot;,Q1_max))</code></pre>
<pre><code>## [1] &quot;quiz 1:  4&quot;</code></pre>
<pre class="r"><code>Q2_max &lt;- min(e$Quiz.2..20, na.rm=TRUE)
print(paste(&quot;quiz 2: &quot;,Q2_max))</code></pre>
<pre><code>## [1] &quot;quiz 2:  6.5&quot;</code></pre>
<pre class="r"><code>Q3_max &lt;- 20/15*min(e$Quiz.3..15, na.rm=TRUE)
print(paste(&quot;quiz 3: &quot;,Q3_max))</code></pre>
<pre><code>## [1] &quot;quiz 3:  9.33333333333333&quot;</code></pre>
</div>
